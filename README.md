# A* Algorithm for Pathfinding

This is an implementation of the A* algorithm in Python, used to find the best path from a starting point 'S' to a goal 'G' on a given matrix. The algorithm uses the Manhattan distance as the heuristic to guide the search.

## How to use

1. Run the `main()` function to see the algorithm in action.
2. The `staticMatrix` variable contains the example matrix on which the algorithm will operate. You can modify this matrix to test with different scenarios.
3. The algorithm will display the process step-by-step, showing the openSet and closeSet, and the cells explored during the search.

## Dependencies

This implementation requires the following libraries:

- numpy
- matplotlib
- termcolor

## Code Explanation
## Explanation of openSet and closeSet

In this A* algorithm implementation, the openSet and closeSet arrays are used to keep track of the nodes being explored and the nodes that have already been explored, respectively.

1. **openSet**: This array represents the set of nodes that have not been fully explored yet. These nodes are potential candidates for the next move. The A* algorithm examines the nodes in the openSet to decide which node is the best one to explore next. The choice is based on the accumulated distance from the initial node to the current node plus a heuristic that estimates the distance from that node to the goal node (in this case, the Manhattan distance is used).

2. **closeSet**: This array represents the set of nodes that have already been explored. Once a node in the openSet is explored, it is moved to the closeSet. The A* algorithm will not re-explore nodes that are already in the closeSet to avoid infinite loops or unnecessary repetitions.

The A* algorithm follows these steps:

1. Initialize the openSet and closeSet as empty arrays and add the initial node (position S) to the openSet.

2. While the openSet is not empty:
   a. Select the node with the lowest cost (sum of the accumulated distance and the heuristic) from the openSet. This node becomes the current node being explored.
   b. If the current node is the goal node (G), then the shortest path has been found.
   c. Otherwise, expand the current node and generate possible moves (children) based on the allowed directions (up, down, left, right). Add these child nodes to the openSet if they are not in the closeSet and are valid paths (not blocked by obstacles in the matrix).
   d. After expanding the current node, move it to the closeSet to avoid re-exploring it.

3. If the A* algorithm has finished and has not found the goal node (G), it means that there is no possible path from the initial node to the goal node, and the algorithm terminates without success.

The code consists of the following main functions:

1. `createMatrix(N, M)`: Creates a matrix of size N x M.
2. `showMatrix(matrix, color=False, closeSet=None)`: Displays the matrix. If 'color' is set to True, the openSet and closeSet cells are shown in different colors.
3. `generateRandomObstacles(matrix, nObstacles)`: Generates random obstacles in the matrix to simulate a more complex environment.
4. `startMoving(matrix, currentPosition, openSet, closeSet, index=0, anterior=None, badWays=set())`: Recursive function that performs the A* search algorithm.
5. `deleteBadWays(bestMove, closeSet, openSet, badWays)`: Deletes bad paths from the closeSet and corresponding paths generated by the algorithm.
6. `paintCells(matrix, closeset)`: Visualizes the progress of the algorithm by displaying the matrix with colors representing the openSet and closeSet cells.
7. `checkBestmove(openSet)`: Finds the best move based on the cost (Manhattan distance) in the openSet.
8. `checkCorrectPosition(move, matrix)`: Checks if a move is valid and within the boundaries of the matrix.
9. `manhatamDistance(move, goal=(5, 18))`: Computes the Manhattan distance between the current cell and the goal.

The `main()` function initializes the algorithm with the provided `staticMatrix`, sets the starting position as (0, 0), and then calls the `startMoving()` function to begin the search. After the algorithm finishes, it displays the best path found in the `closeSet` and the `badWays`, which are paths that were discarded during the search due to no possible solutions.

Remember to adjust the `staticMatrix` and the number of obstacles in the `generateRandomObstacles()` function to experiment with different scenarios.

